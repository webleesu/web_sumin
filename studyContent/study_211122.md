## 21.11.22

#### javascript

b_13_

#### 생성자함수

- 함수를 생성한다는 의미를 가지지만, 원본으로 만들어서 사용할 때는 별도의 복제본을 쓰는 것

- PascalCase로 처리

- 예시

  ```js
  var UserSetting = function(userName, userAge, userEmail){};
  ```



#### this

1. window

​	<img this_window>



2. 일반함수 - window이지만, 엄격모드('use strict')로 전환시 undefined
   - `'use strict';` 모드를 사용하면 일반 함수 내의 this는 undefined를 가르킨다. 



3. 생성자 함수로 만들어진 객체

```js
var UserSetting = function(userName, userAge, userEmail){
  this.name = userName;
  this.age = userAge;
  this.email = userEmail;
};
```



4. 메서드 처리시 객체로 처리되어있는 변수명

   ```js
   var lastName = 'hong';
   var firstName = 'gildong'
   
   var useFile = {
     firstName : 'sumin',
     lastName : 'lee',
     job : 'developer',
     subJob : 'student',
     fullName : function(){
       // return lastName + ' ' + firstName; // 외부에서 선언된 변수 'lastName', 'firstName' 을 의미 - hong gildong
       return this.lastName + ' ' + this.firstName; // lee sumin
     }
   };
   ```



5. 이벤트 핸들러

- 이벤트의 주체가 되는 선택자

  ```js
  btn.addEventListener('이벤트 내용', function(e){});
  ```

  ```js
  var btn = document.querySelector('#btn');
  btn.addEventListener('click', function(e){
    console.log(this); // #btn
  });
  ```

  





#### prototype

- 생성자에 담길 내용에 대한 별도의 처리되는 기본 객체

- prototype은 하나의 기 능을 사용할 수 있는 환경을 구축하는 처리형태

- 사용하는 변수 값 자체에 있는 기능은 아니고, 본연의 타입형태에 담겨 처리할 수 있도록 만드는 것

- 예시

  ```js
  UserSetting.prototype.group = '가족 명단 체크';
  ```

  <img prototype>

- ```js
  UserSetting.prototype.trueCheck = function(){
    return this.age / 2;
  }
  
  console.log(user1.trueCheck()); // user age가 20 이었다면 결과는 10
  ```



#### use strict

- 엄격하게 기능을 제한하여 처리하는 모드

- ```js
  'use strict'; // 제일 위에 입력
  ```



#### call() = apply()

- `this`를 바꿔주는 메서드

  ```js
  var obj = {
    string : 'sumin',
    reName : function(){
      console.log( 'name: ', this.string);
    }
  };
  
  obj.reName(); // name:  sumin
  
  var obj2 = {
    string : 'sub name'
  };
  
  console.log(obj2.string); // sub name
  obj.reName.call(obj2); // name:  sub name
  
  ```

- `call`과 `apply`의 차이

  ```js
  var objBox = {
    penname : 'board maker',
    rename : function(){
      console.log(this.penname);
    }
  }
  
  var obj1 = {penname : ['sharp', 'magic']};
  objBox.rename.call(obj1); // call(null, (여러 arguments))
  objBox.rename.apply(obj1); // apply(null, [list])
  // console.log( objBox2.penname );
  ```



#### 유사배열

```js
var listFn = function(){
  return arguments;
}

var makeList = listFn('test', 'file', 1, 2, 5, 7, 10);
console.log(makeList);
```

- 유사배열을 배열로 바꾸는 코드

```js
var listFn = function(){
  return Array.prototype.slice.call(arguments);
}
```

- 문자로 처리

```js
var listFn = function(){
  return Array.prototype.join.call(arguments); // 문자로 처리
}
```

- 문자로 처리한 것을 다시 배열로 처리

```js
var listFn = function(){
  return Array.prototype.join.call(arguments).split(','); // 문자로 처리한 것을 배열로 처리
}
```









